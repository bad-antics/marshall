//! Exploit Database - Collection of obscure and cutting-edge exploits
//! 
//! Dr. Marshall's knowledge base of techniques most security researchers
//! haven't encountered.

use super::*;
use std::collections::HashMap;

pub struct ExploitDatabase {
    pub exploits: HashMap<String, Exploit>,
}

impl ExploitDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            exploits: HashMap::new(),
        };
        
        // Load obscure exploits
        db.load_obscure_exploits();
        db.load_kernel_exploits();
        db.load_browser_exploits();
        db.load_network_exploits();
        db.load_hardware_exploits();
        
        db
    }
    
    fn load_obscure_exploits(&mut self) {
        // Obscure techniques not widely known
        
        self.add_exploit(Exploit {
            id: "NS-2026-001".into(),
            name: "Shadow Stack Bypass via Exception Handler Hijacking".into(),
            aliases: vec!["CET-Bypass".into(), "Shadow-Stack-Escape".into()],
            description: "Bypasses Intel CET shadow stack protection by manipulating \
                         exception handling metadata. Works by exploiting the gap \
                         between shadow stack validation and exception unwinding.".into(),
            category: ExploitCategory::ROP,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Windows 11".into(), "Linux 6.x".into()],
            prerequisites: vec![
                "Target must have CET enabled".into(),
                "Exception handler must be controllable".into(),
            ],
            payload: None,
            poc_code: Some(include_str!("pocs/shadow_stack_bypass.txt").into()),
            mitigations: vec!["Harden exception handler chains".into()],
            references: vec![],
            obscurity_level: 9,
            detection_difficulty: 9,
            reliability: 7,
        });
        
        self.add_exploit(Exploit {
            id: "NS-2026-002".into(),
            name: "Speculative Store Bypass via Branch Prediction Collision".into(),
            aliases: vec!["SSB-BPC".into(), "Ghost-Store".into()],
            description: "Novel side-channel attack combining speculative store bypass \
                         with branch predictor collisions to leak kernel memory from \
                         userspace without triggering existing mitigations.".into(),
            category: ExploitCategory::SideChannel,
            severity: Severity::High,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Intel 12th-14th Gen".into(), "AMD Zen 3/4".into()],
            prerequisites: vec![
                "Precise timing capability".into(),
                "Shared branch predictor state".into(),
            ],
            payload: None,
            poc_code: None,
            mitigations: vec!["Flush branch predictor on context switch".into()],
            references: vec![],
            obscurity_level: 10,
            detection_difficulty: 10,
            reliability: 5,
        });
        
        self.add_exploit(Exploit {
            id: "NS-2026-003".into(),
            name: "TPM 2.0 Key Extraction via Power Analysis on SPI Bus".into(),
            aliases: vec!["TPM-SPI-Side".into(), "Bitlocker-Bypass".into()],
            description: "Extract TPM-sealed keys by analyzing power fluctuations \
                         on the SPI bus during TPM communication. Can bypass \
                         BitLocker/LUKS on laptops with discrete TPM chips.".into(),
            category: ExploitCategory::Hardware,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec![
                "Discrete TPM 2.0 chips".into(),
                "Laptops with exposed SPI bus".into(),
            ],
            prerequisites: vec![
                "Physical access".into(),
                "Oscilloscope or logic analyzer".into(),
                "SPI bus probes".into(),
            ],
            payload: None,
            poc_code: None,
            mitigations: vec!["Use fTPM (firmware TPM)".into(), "Add TPM-to-CPU encryption".into()],
            references: vec![],
            obscurity_level: 8,
            detection_difficulty: 10, // Undetectable in software
            reliability: 8,
        });
        
        self.add_exploit(Exploit {
            id: "NS-2026-004".into(),
            name: "UEFI Variable Corruption via SMM Cache Poisoning".into(),
            aliases: vec!["SMM-Cache-Poison".into(), "UEFI-Persist".into()],
            description: "Achieve UEFI persistence by corrupting SMM cache during \
                         variable write operations. Survives OS reinstalls, BIOS \
                         updates, and most forensic analysis.".into(),
            category: ExploitCategory::Bootkit,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Most UEFI systems".into()],
            prerequisites: vec![
                "Kernel execution".into(),
                "Vulnerable UEFI implementation".into(),
            ],
            payload: None,
            poc_code: None,
            mitigations: vec!["Hardware-backed secure boot".into(), "SMM isolation".into()],
            references: vec![],
            obscurity_level: 9,
            detection_difficulty: 9,
            reliability: 6,
        });
        
        self.add_exploit(Exploit {
            id: "NS-2026-005".into(),
            name: "DNS Rebinding via HTTP/3 QUIC Multiplexing".into(),
            aliases: vec!["QUIC-Rebind".into(), "H3-Intranet".into()],
            description: "Bypass same-origin policy using QUIC's connection migration \
                         and stream multiplexing to rebind DNS mid-connection without \
                         triggering standard DNS rebinding protections.".into(),
            category: ExploitCategory::SSRF,
            severity: Severity::High,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Chrome".into(), "Firefox".into(), "Edge".into()],
            prerequisites: vec![
                "Victim visits attacker site".into(),
                "Internal service on target network".into(),
            ],
            payload: None,
            poc_code: None,
            mitigations: vec!["Disable QUIC for internal resources".into()],
            references: vec![],
            obscurity_level: 8,
            detection_difficulty: 8,
            reliability: 7,
        });
    }
    
    fn load_kernel_exploits(&mut self) {
        self.add_exploit(Exploit {
            id: "NS-KERN-001".into(),
            name: "io_uring Credential Confusion via Task Work Hijacking".into(),
            aliases: vec!["io_uring-cred-swap".into()],
            description: "Exploit io_uring's deferred work mechanism to swap credentials \
                         between tasks, allowing privilege escalation without triggering \
                         standard LSM hooks.".into(),
            category: ExploitCategory::PrivilegeEscalation,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Linux 5.x-6.x".into()],
            prerequisites: vec!["Unprivileged io_uring access".into()],
            payload: None,
            poc_code: None,
            mitigations: vec!["Disable io_uring for unprivileged users".into()],
            references: vec![],
            obscurity_level: 8,
            detection_difficulty: 8,
            reliability: 7,
        });
        
        self.add_exploit(Exploit {
            id: "NS-KERN-002".into(),
            name: "Windows ETW Blind Spot via Session0 Service Injection".into(),
            aliases: vec!["ETW-Blind".into(), "Session0-Ghost".into()],
            description: "Achieve kernel-level stealth by injecting into Session0 \
                         services that aren't monitored by standard ETW consumers. \
                         Bypasses most EDR solutions.".into(),
            category: ExploitCategory::LivingOffTheLand,
            severity: Severity::High,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Windows 10/11".into()],
            prerequisites: vec!["SeDebugPrivilege".into()],
            payload: None,
            poc_code: None,
            mitigations: vec!["Monitor Session0 processes".into()],
            references: vec![],
            obscurity_level: 7,
            detection_difficulty: 9,
            reliability: 8,
        });
    }
    
    fn load_browser_exploits(&mut self) {
        self.add_exploit(Exploit {
            id: "NS-BROWSER-001".into(),
            name: "V8 JIT Spray via WebAssembly Memory Corruption".into(),
            aliases: vec!["V8-WASM-Spray".into()],
            description: "Use WebAssembly's predictable memory layout to spray JIT \
                         shellcode that survives V8's pointer compression and ASLR.".into(),
            category: ExploitCategory::HeapOverflow,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Chrome/Chromium".into(), "Node.js".into()],
            prerequisites: vec!["JavaScript execution".into()],
            payload: None,
            poc_code: None,
            mitigations: vec!["Disable WebAssembly".into()],
            references: vec![],
            obscurity_level: 7,
            detection_difficulty: 6,
            reliability: 6,
        });
    }
    
    fn load_network_exploits(&mut self) {
        self.add_exploit(Exploit {
            id: "NS-NET-001".into(),
            name: "BGP Hijacking via RPKI ROA Manipulation".into(),
            aliases: vec!["RPKI-Bypass".into(), "BGP-MitM".into()],
            description: "Hijack BGP prefixes even with RPKI validation by exploiting \
                         timing windows in ROA updates and max-length ambiguities.".into(),
            category: ExploitCategory::AuthBypass,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Internet routing infrastructure".into()],
            prerequisites: vec!["BGP peering capability".into(), "Rogue AS".into()],
            payload: None,
            poc_code: None,
            mitigations: vec!["Strict RPKI validation".into()],
            references: vec![],
            obscurity_level: 9,
            detection_difficulty: 7,
            reliability: 6,
        });
    }
    
    fn load_hardware_exploits(&mut self) {
        self.add_exploit(Exploit {
            id: "NS-HW-001".into(),
            name: "PCIe DMA Attack via Thunderbolt Chained Tunnel".into(),
            aliases: vec!["TB-DMA-Chain".into()],
            description: "Bypass DMA protections by chaining Thunderbolt tunnels \
                         through multiple devices to confuse IOMMU mapping.".into(),
            category: ExploitCategory::Hardware,
            severity: Severity::Critical,
            cve: None,
            discovered_date: None,
            affected_systems: vec!["Thunderbolt 3/4 systems".into()],
            prerequisites: vec!["Malicious Thunderbolt device chain".into()],
            payload: None,
            poc_code: None,
            mitigations: vec!["Disable Thunderbolt".into(), "Kernel DMA protection".into()],
            references: vec![],
            obscurity_level: 8,
            detection_difficulty: 9,
            reliability: 7,
        });
    }
    
    fn add_exploit(&mut self, exploit: Exploit) {
        self.exploits.insert(exploit.id.clone(), exploit);
    }
    
    pub fn search(&self, query: &str) -> Vec<&Exploit> {
        let query_lower = query.to_lowercase();
        
        self.exploits.values()
            .filter(|e| {
                e.name.to_lowercase().contains(&query_lower) ||
                e.description.to_lowercase().contains(&query_lower) ||
                e.aliases.iter().any(|a| a.to_lowercase().contains(&query_lower)) ||
                e.cve.as_ref().map(|c| c.contains(&query_lower)).unwrap_or(false)
            })
            .collect()
    }
    
    pub fn get_by_category(&self, category: &ExploitCategory) -> Vec<&Exploit> {
        self.exploits.values()
            .filter(|e| std::mem::discriminant(&e.category) == std::mem::discriminant(category))
            .collect()
    }
}
