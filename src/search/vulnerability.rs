// Copyright (c) 2026 bad-antics
// OSINT Search - Vulnerability Scanner & Exploit Lookup

use serde::{Deserialize, Serialize};
use super::portscan::PortInfo;
use std::collections::HashMap;

/// Vulnerability information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnInfo {
    pub cve_id: String,
    pub title: String,
    pub description: String,
    pub severity: String,
    pub cvss_score: f32,
    pub cvss_vector: Option<String>,
    pub affected_service: String,
    pub affected_versions: Vec<String>,
    pub published_date: Option<String>,
    pub references: Vec<String>,
    pub has_exploit: bool,
}

/// Exploit information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitInfo {
    pub id: String,
    pub title: String,
    pub description: String,
    pub cve_id: Option<String>,
    pub exploit_type: ExploitType,
    pub platform: String,
    pub author: Option<String>,
    pub source: String,
    pub source_url: Option<String>,
    pub reliability: Reliability,
    pub verified: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExploitType {
    RemoteCodeExecution,
    LocalPrivilegeEscalation,
    DenialOfService,
    InformationDisclosure,
    SQLInjection,
    XSS,
    BufferOverflow,
    AuthenticationBypass,
    DirectoryTraversal,
    Other,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Reliability {
    Excellent,  // Tested, works reliably
    Good,       // Works in most cases
    Normal,     // May require modification
    Low,        // Proof of concept only
}

/// Vulnerability scanner
pub struct VulnerabilityScanner {
    vuln_database: VulnDatabase,
    exploit_database: ExploitDatabase,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            vuln_database: VulnDatabase::new(),
            exploit_database: ExploitDatabase::new(),
        }
    }

    /// Scan for vulnerabilities based on open ports
    pub async fn scan(&self, _domain: &str, open_ports: &[PortInfo]) -> Vec<VulnInfo> {
        let mut vulns = Vec::new();

        for port in open_ports {
            // Check for known vulnerabilities for this service
            if let Some(service_vulns) = self.vuln_database.get_by_service(&port.service) {
                vulns.extend(service_vulns);
            }

            // Check banner for version info and specific vulns
            if let Some(banner) = &port.banner {
                let version_vulns = self.check_banner_vulns(banner, &port.service);
                vulns.extend(version_vulns);
            }
        }

        // Deduplicate by CVE ID
        vulns.sort_by(|a, b| a.cve_id.cmp(&b.cve_id));
        vulns.dedup_by(|a, b| a.cve_id == b.cve_id);

        vulns
    }

    /// Find exploits for discovered vulnerabilities
    pub async fn find_exploits(&self, vulns: &[VulnInfo]) -> Vec<ExploitInfo> {
        let mut exploits = Vec::new();

        for vuln in vulns {
            if let Some(cve_exploits) = self.exploit_database.get_by_cve(&vuln.cve_id) {
                exploits.extend(cve_exploits);
            }
        }

        exploits
    }

    /// Check banner for version-specific vulnerabilities
    fn check_banner_vulns(&self, banner: &str, service: &str) -> Vec<VulnInfo> {
        let banner_lower = banner.to_lowercase();
        let mut vulns = Vec::new();

        // Apache vulnerabilities
        if banner_lower.contains("apache") {
            if banner_lower.contains("2.4.49") || banner_lower.contains("2.4.50") {
                vulns.push(VulnInfo {
                    cve_id: "CVE-2021-41773".to_string(),
                    title: "Apache Path Traversal".to_string(),
                    description: "Path traversal and file disclosure vulnerability in Apache HTTP Server 2.4.49 and 2.4.50".to_string(),
                    severity: "critical".to_string(),
                    cvss_score: 9.8,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
                    affected_service: service.to_string(),
                    affected_versions: vec!["2.4.49".to_string(), "2.4.50".to_string()],
                    published_date: Some("2021-10-05".to_string()),
                    references: vec![
                        "https://httpd.apache.org/security/vulnerabilities_24.html".to_string(),
                        "https://nvd.nist.gov/vuln/detail/CVE-2021-41773".to_string(),
                    ],
                    has_exploit: true,
                });
            }
        }

        // OpenSSH vulnerabilities
        if banner_lower.contains("openssh") {
            if banner_lower.contains("7.") || banner_lower.contains("6.") {
                vulns.push(VulnInfo {
                    cve_id: "CVE-2018-15473".to_string(),
                    title: "OpenSSH User Enumeration".to_string(),
                    description: "OpenSSH user enumeration vulnerability allowing attackers to determine valid usernames".to_string(),
                    severity: "medium".to_string(),
                    cvss_score: 5.3,
                    cvss_vector: Some("CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N".to_string()),
                    affected_service: service.to_string(),
                    affected_versions: vec!["< 7.7".to_string()],
                    published_date: Some("2018-08-17".to_string()),
                    references: vec![
                        "https://nvd.nist.gov/vuln/detail/CVE-2018-15473".to_string(),
                    ],
                    has_exploit: true,
                });
            }
        }

        // nginx vulnerabilities
        if banner_lower.contains("nginx") {
            if banner_lower.contains("1.16") || banner_lower.contains("1.17") {
                vulns.push(VulnInfo {
                    cve_id: "CVE-2019-20372".to_string(),
                    title: "nginx HTTP Request Smuggling".to_string(),
                    description: "HTTP request smuggling vulnerability in nginx when using error_page directive".to_string(),
                    severity: "medium".to_string(),
                    cvss_score: 5.3,
                    cvss_vector: None,
                    affected_service: service.to_string(),
                    affected_versions: vec!["< 1.17.7".to_string()],
                    published_date: Some("2020-01-09".to_string()),
                    references: vec![
                        "https://nvd.nist.gov/vuln/detail/CVE-2019-20372".to_string(),
                    ],
                    has_exploit: false,
                });
            }
        }

        // Microsoft IIS vulnerabilities
        if banner_lower.contains("microsoft-iis") || banner_lower.contains("iis/") {
            vulns.push(VulnInfo {
                cve_id: "CVE-2017-7269".to_string(),
                title: "IIS WebDAV ScStoragePathFromUrl Buffer Overflow".to_string(),
                description: "Buffer overflow in the ScStoragePathFromUrl function in IIS 6.0".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: None,
                affected_service: service.to_string(),
                affected_versions: vec!["IIS 6.0".to_string()],
                published_date: Some("2017-03-26".to_string()),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2017-7269".to_string(),
                ],
                has_exploit: true,
            });
        }

        // SMB vulnerabilities
        if service.to_lowercase() == "smb" || service == "445" {
            vulns.push(VulnInfo {
                cve_id: "CVE-2017-0144".to_string(),
                title: "EternalBlue SMB RCE".to_string(),
                description: "SMBv1 server allows remote code execution (EternalBlue/WannaCry)".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: Some("CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
                affected_service: service.to_string(),
                affected_versions: vec!["Windows SMBv1".to_string()],
                published_date: Some("2017-03-14".to_string()),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2017-0144".to_string(),
                ],
                has_exploit: true,
            });
        }

        // RDP vulnerabilities
        if service.to_lowercase() == "rdp" || service == "3389" {
            vulns.push(VulnInfo {
                cve_id: "CVE-2019-0708".to_string(),
                title: "BlueKeep RDP RCE".to_string(),
                description: "Remote code execution vulnerability in Remote Desktop Services (BlueKeep)".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: Some("CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
                affected_service: service.to_string(),
                affected_versions: vec!["Windows 7".to_string(), "Windows Server 2008".to_string()],
                published_date: Some("2019-05-14".to_string()),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2019-0708".to_string(),
                ],
                has_exploit: true,
            });
        }

        vulns
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

/// Local vulnerability database
struct VulnDatabase {
    by_service: HashMap<String, Vec<VulnInfo>>,
}

impl VulnDatabase {
    fn new() -> Self {
        let mut db = Self {
            by_service: HashMap::new(),
        };
        db.populate_common_vulns();
        db
    }

    fn get_by_service(&self, service: &str) -> Option<Vec<VulnInfo>> {
        self.by_service.get(&service.to_lowercase()).cloned()
    }

    fn populate_common_vulns(&mut self) {
        // FTP vulnerabilities
        self.by_service.insert("ftp".to_string(), vec![
            VulnInfo {
                cve_id: "CVE-2011-2523".to_string(),
                title: "vsftpd 2.3.4 Backdoor".to_string(),
                description: "vsftpd 2.3.4 contains a backdoor that opens a shell on port 6200".to_string(),
                severity: "critical".to_string(),
                cvss_score: 10.0,
                cvss_vector: None,
                affected_service: "FTP".to_string(),
                affected_versions: vec!["vsftpd 2.3.4".to_string()],
                published_date: Some("2011-07-03".to_string()),
                references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2011-2523".to_string()],
                has_exploit: true,
            },
        ]);

        // Telnet vulnerabilities
        self.by_service.insert("telnet".to_string(), vec![
            VulnInfo {
                cve_id: "TELNET-CLEARTEXT".to_string(),
                title: "Telnet Cleartext Protocol".to_string(),
                description: "Telnet transmits all data including credentials in cleartext".to_string(),
                severity: "high".to_string(),
                cvss_score: 7.5,
                cvss_vector: None,
                affected_service: "Telnet".to_string(),
                affected_versions: vec!["All".to_string()],
                published_date: None,
                references: vec![],
                has_exploit: false,
            },
        ]);

        // MySQL vulnerabilities
        self.by_service.insert("mysql".to_string(), vec![
            VulnInfo {
                cve_id: "CVE-2012-2122".to_string(),
                title: "MySQL Authentication Bypass".to_string(),
                description: "MySQL authentication can be bypassed by repeated login attempts".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: None,
                affected_service: "MySQL".to_string(),
                affected_versions: vec!["5.1.x".to_string(), "5.5.x".to_string(), "5.6.x".to_string()],
                published_date: Some("2012-06-09".to_string()),
                references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2012-2122".to_string()],
                has_exploit: true,
            },
        ]);

        // Redis vulnerabilities
        self.by_service.insert("redis".to_string(), vec![
            VulnInfo {
                cve_id: "REDIS-NOAUTH".to_string(),
                title: "Redis Unauthenticated Access".to_string(),
                description: "Redis server allows unauthenticated access by default".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: None,
                affected_service: "Redis".to_string(),
                affected_versions: vec!["All (default config)".to_string()],
                published_date: None,
                references: vec![],
                has_exploit: true,
            },
        ]);

        // MongoDB vulnerabilities
        self.by_service.insert("mongodb".to_string(), vec![
            VulnInfo {
                cve_id: "MONGO-NOAUTH".to_string(),
                title: "MongoDB Unauthenticated Access".to_string(),
                description: "MongoDB server allows unauthenticated access by default".to_string(),
                severity: "critical".to_string(),
                cvss_score: 9.8,
                cvss_vector: None,
                affected_service: "MongoDB".to_string(),
                affected_versions: vec!["All (default config)".to_string()],
                published_date: None,
                references: vec![],
                has_exploit: true,
            },
        ]);
    }
}

/// Local exploit database
struct ExploitDatabase {
    by_cve: HashMap<String, Vec<ExploitInfo>>,
}

impl ExploitDatabase {
    fn new() -> Self {
        let mut db = Self {
            by_cve: HashMap::new(),
        };
        db.populate_common_exploits();
        db
    }

    fn get_by_cve(&self, cve_id: &str) -> Option<Vec<ExploitInfo>> {
        self.by_cve.get(cve_id).cloned()
    }

    fn populate_common_exploits(&mut self) {
        // EternalBlue exploit
        self.by_cve.insert("CVE-2017-0144".to_string(), vec![
            ExploitInfo {
                id: "EDB-42315".to_string(),
                title: "EternalBlue SMBv1 RCE".to_string(),
                description: "MS17-010 SMBv1 Remote Code Execution".to_string(),
                cve_id: Some("CVE-2017-0144".to_string()),
                exploit_type: ExploitType::RemoteCodeExecution,
                platform: "Windows".to_string(),
                author: Some("Shadow Brokers/NSA".to_string()),
                source: "Exploit-DB".to_string(),
                source_url: Some("https://www.exploit-db.com/exploits/42315".to_string()),
                reliability: Reliability::Excellent,
                verified: true,
            },
        ]);

        // BlueKeep exploit
        self.by_cve.insert("CVE-2019-0708".to_string(), vec![
            ExploitInfo {
                id: "MSF-BLUEKEEP".to_string(),
                title: "BlueKeep RDP RCE".to_string(),
                description: "Remote Desktop Services Remote Code Execution".to_string(),
                cve_id: Some("CVE-2019-0708".to_string()),
                exploit_type: ExploitType::RemoteCodeExecution,
                platform: "Windows".to_string(),
                author: Some("Metasploit".to_string()),
                source: "Metasploit".to_string(),
                source_url: Some("https://github.com/rapid7/metasploit-framework".to_string()),
                reliability: Reliability::Good,
                verified: true,
            },
        ]);

        // Apache Path Traversal
        self.by_cve.insert("CVE-2021-41773".to_string(), vec![
            ExploitInfo {
                id: "EDB-50383".to_string(),
                title: "Apache 2.4.49/2.4.50 Path Traversal".to_string(),
                description: "Apache HTTP Server Path Traversal & RCE".to_string(),
                cve_id: Some("CVE-2021-41773".to_string()),
                exploit_type: ExploitType::DirectoryTraversal,
                platform: "Linux".to_string(),
                author: None,
                source: "Exploit-DB".to_string(),
                source_url: Some("https://www.exploit-db.com/exploits/50383".to_string()),
                reliability: Reliability::Excellent,
                verified: true,
            },
        ]);

        // vsftpd backdoor
        self.by_cve.insert("CVE-2011-2523".to_string(), vec![
            ExploitInfo {
                id: "MSF-VSFTPD".to_string(),
                title: "vsftpd 2.3.4 Backdoor Command Execution".to_string(),
                description: "vsftpd 2.3.4 malicious backdoor".to_string(),
                cve_id: Some("CVE-2011-2523".to_string()),
                exploit_type: ExploitType::RemoteCodeExecution,
                platform: "Linux".to_string(),
                author: Some("Metasploit".to_string()),
                source: "Metasploit".to_string(),
                source_url: None,
                reliability: Reliability::Excellent,
                verified: true,
            },
        ]);
    }
}

/// Format vulnerability info for display
pub fn format_vuln_info(vuln: &VulnInfo) -> String {
    let severity_color = match vuln.severity.as_str() {
        "critical" => "ðŸ”´",
        "high" => "ðŸŸ ",
        "medium" => "ðŸŸ¡",
        "low" => "ðŸŸ¢",
        _ => "âšª",
    };

    format!(
        "{} {} | {} | CVSS: {:.1} | {}",
        severity_color,
        vuln.cve_id,
        vuln.title,
        vuln.cvss_score,
        if vuln.has_exploit { "âš¡ EXPLOIT" } else { "" }
    )
}

/// Format exploit info for display
pub fn format_exploit_info(exploit: &ExploitInfo) -> String {
    let reliability = match exploit.reliability {
        Reliability::Excellent => "â˜…â˜…â˜…â˜…",
        Reliability::Good => "â˜…â˜…â˜…â˜†",
        Reliability::Normal => "â˜…â˜…â˜†â˜†",
        Reliability::Low => "â˜…â˜†â˜†â˜†",
    };

    format!(
        "âš¡ {} | {} | {} | {}",
        exploit.id,
        exploit.title,
        exploit.platform,
        reliability
    )
}
